<h1>x86/HVM direct boot ABI</h1>

<p>Since the Xen entry point into the kernel can be different from the
native entry point, a <code>ELFNOTE</code> is used in order to tell the domain
builder how to load and jump into the kernel entry point:</p>

<pre><code>ELFNOTE(Xen, XEN_ELFNOTE_PHYS32_ENTRY,          .long,  xen_start32)
</code></pre>

<p>The presence of the <code>XEN_ELFNOTE_PHYS32_ENTRY</code> note indicates that the
kernel supports the boot ABI described in this document.</p>

<p>The domain builder must load the kernel into the guest memory space and
jump into the entry point defined at <code>XEN_ELFNOTE_PHYS32_ENTRY</code> with the
following machine state:</p>

<ul>
<li><p><code>ebx</code>: contains the physical memory address where the loader has placed
the boot start info structure.</p></li>
<li><p><code>cr0</code>: bit 0 (PE) must be set. All the other writeable bits are cleared.</p></li>
<li><p><code>cr4</code>: all bits are cleared.</p></li>
<li><p><code>cs</code>: must be a 32-bit read/execute code segment with a base of ‘0’
and a limit of ‘0xFFFFFFFF’. The selector value is unspecified.</p></li>
<li><p><code>ds</code>, <code>es</code>: must be a 32-bit read/write data segment with a base of
‘0’ and a limit of ‘0xFFFFFFFF’. The selector values are all unspecified.</p></li>
<li><p><code>tr</code>: must be a 32-bit TSS (active) with a base of '0' and a limit of '0x67'.</p></li>
<li><p><code>eflags</code>: bit 17 (VM) must be cleared. Bit 9 (IF) must be cleared.
Bit 8 (TF) must be cleared. Other bits are all unspecified.</p></li>
</ul>

<p>All other processor registers and flag bits are unspecified. The OS is in
charge of setting up it's own stack, GDT and IDT.</p>

<p>The format of the boot start info structure (pointed to by %ebx) can be found
in xen/include/public/arch-x86/hvm/start_info.h</p>

<p>Other relevant information needed in order to boot a guest kernel
(console page address, xenstore event channel...) can be obtained
using HVMPARAMS, just like it's done on HVM guests.</p>

<p>The setup of the hypercall page is also performed in the same way
as HVM guests, using the hypervisor cpuid leaves and msr ranges.</p>

<h2>AP startup</h2>

<p>AP startup can be performed using hypercalls or the local APIC if present.
The following VCPU hypercalls can be used in order to bring up secondary vCPUs:</p>

<ul>
<li><p><code>VCPUOP_initialise</code> is used to set the initial state of the vCPU. The
argument passed to the hypercall must be of the type vcpu_hvm_context.
See <code>public/hvm/hvm_vcpu.h</code> for the layout of the structure. Note that
this hypercall allows starting the vCPU in several modes (16/32/64bits),
regardless of the mode the BSP is currently running on.</p></li>
<li><p><code>VCPUOP_up</code> is used to launch the vCPU once the initial state has been
set using <code>VCPUOP_initialise</code>.</p></li>
<li><p><code>VCPUOP_down</code> is used to bring down a vCPU.</p></li>
<li><p><code>VCPUOP_is_up</code> is used to scan the number of available vCPUs.</p></li>
</ul>

<h2>Hardware description</h2>

<p>PVHv2 guests that have access to hardware (either emulated or real) will also
have ACPI tables with the description of the hardware that's available to the
guest. This applies to both privileged and unprivileged guests. A pointer to
the position of the RSDP in memory (if present) can be fetched from the start
info structure that's passed at boot time (field rsdp_paddr).</p>

<p>Description of paravirtualized devices will come from XenStore, just as it's
done for HVM guests.</p>

<h2>Interrupts</h2>

<h3>Interrupts from physical devices</h3>

<p>Interrupts from physical devices are delivered using native methods, this is
done in order to take advantage of new hardware assisted virtualization
functions, like posted interrupts. This implies that PVHv2 guests with physical
devices will also have the necessary interrupt controllers in order to manage
the delivery of interrupts from those devices, using the same interfaces that
are available on native hardware.</p>

<h3>Interrupts from paravirtualized devices</h3>

<p>Interrupts from paravirtualized devices are delivered using event channels, see
[Event Channel Internals][event_channels] for more detailed information about
event channels. Delivery of those interrupts can be configured in the same way
as HVM guests, check xen/include/public/hvm/params.h and
xen/include/public/hvm/hvm_op.h for more information about available delivery
methods.</p>
