<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Xen PV Channels</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:root@localhost" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#How-to-use-channels:-an-example">How to use channels: an example</a></li>
      <li><a href="#Design-recommendations-and-pitfalls">Design recommendations and pitfalls</a></li>
      <li><a href="#Limitations">Limitations</a></li>
      <li><a href="#Channel-name-registry">Channel name registry</a></li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Xen PV Channels</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>A channel is a low-bandwidth private byte stream similar to a serial link. Typical uses of channels are</p>

<ol>

<li><p>to provide initial configuration information to a VM on boot (example use: CloudStack&#39;s cloud-early-config service)</p>

</li>
<li><p>to signal/query an in-guest agent (example use: oVirt&#39;s guest agent)</p>

</li>
</ol>

<p>Channels are similar to virtio-serial devices and emulated serial links. Channels are intended to be used in the implementation of libvirt s when running on Xen.</p>

<p>Note: if an application requires a high-bandwidth link then it should use vchan instead.</p>

<h2 id="How-to-use-channels:-an-example">How to use channels: an example</h2>

<p>Consider a cloud deployment where VMs are cloned from pre-made templates, and customised on first boot by an in-guest agent which sets the IP address, hostname, ssh keys etc. To install the system the cloud administrator would first:</p>

<ol>

<li><p>Install a guest as normal (no channel configuration necessary)</p>

</li>
<li><p>Install the in-guest agent specific to the cloud software. This will prepare the guest to communicate over the channel, and also prepare the guest to be cloned safely (sometimes known as &quot;sysprepping&quot;)</p>

</li>
<li><p>Shutdown the guest</p>

</li>
<li><p>Register the guest as a template with the cloud orchestration software</p>

</li>
<li><p>Install the cloud orchestration agent in dom0</p>

</li>
</ol>

<p>At runtime, when a cloud tenant requests that a VM is created from the template, the sequence of events would be: (assuming a Linux domU)</p>

<ol>

<li><p>A VM is &quot;cloned&quot; from the template</p>

</li>
<li><p>A unique Unix domain socket path in dom0 is allocated (e.g. /my/cloud/software/talk/to/domain/)</p>

</li>
<li><p>Domain configuration is created for the VM, listing the channel name expected by the in-guest agent. In xl syntax this would be:</p>

<p>channel = [ &quot;connection=socket, name=org.my.cloud.software.agent.version1, path = /my/cloud/software/talk/to/domain/&quot; ]</p>

</li>
<li><p>The VM is started</p>

</li>
<li><p>In dom0 the cloud orchestration agent connects to the Unix domain socket, writes a handshake message and waits for a reply</p>

</li>
<li><p>Assuming the guest kernel has CONFIG_HVC_XEN_FRONTEND set then the console driver will generate a hotplug event</p>

</li>
<li><p>A udev rule is activated by the hotplug event.</p>

<p>The udev rule would look something like:</p>

<p>SUBSYSTEM==&quot;xen&quot;, DEVPATH==&quot;/devices/console-[0-9]&quot;, RUN+=&quot;xen-console-setup&quot;</p>

<p>where the &quot;xen-console-setup&quot; script would read the channel name and make a symlink in /dev/xen-channel/org.my.cloud.software.agent.version1 pointing to /dev/hvcN. N is the same number as the number in &quot;/devices/console-[0-9]&quot;. In other words, &quot;/devices/console-2&quot; maps to /dev/hvc2.</p>

</li>
<li><p>The in-guest agent uses inotify to see the creation of the /dev/xen-channel symlink and opens the device.</p>

</li>
<li><p>The in-guest agent completes the handshake with the dom0 agent</p>

</li>
<li><p>The dom0 agent transmits the unique VM configuration: hostname, IP address, ssh keys etc etc</p>

</li>
<li><p>The in-guest agent receives the configuration and applies it.</p>

</li>
</ol>

<p>Using channels avoids having to use a temporary disk device or network connection.</p>

<h2 id="Design-recommendations-and-pitfalls">Design recommendations and pitfalls</h2>

<p>It&#39;s necessary to install channel-specific software (an &quot;agent&quot;) into the guest before you can use a channel. By default a channel will appear as a device which could be mistaken for a serial port or regular console. It is known that some software will proactively seek out serial ports and issue AT commands at them; make sure such software is disabled!</p>

<p>Since channels are identified by names, application authors must ensure their channel names are unique to avoid clashes. We recommend that channel names include parts unique to the application such as a domain names. To assist prevent clashes we recommend authors add their names to our global channel registry at the end of this document.</p>

<h2 id="Limitations">Limitations</h2>

<p>Hotplug and unplug of channels is not currently implemented.</p>

<h2 id="Channel-name-registry">Channel name registry</h2>

<p>It is important that channel names are globally unique. To help ensure that no-one&#39;s name clashes with yours, please add yours to this list.</p>

<pre><code>    Key:
    N: Name
    C: Contact
    D: Short description of use, possibly including a URL to your software or API

    N: org.xenproject.guest.clipboard.0.1
    C: David Scott &lt;dave.scott@citrix.com&gt;
    D: Share clipboard data via an in-guest agent. See:
       http://wiki.xenproject.org/wiki/Clipboard_sharing_protocol</code></pre>


</body>

</html>


