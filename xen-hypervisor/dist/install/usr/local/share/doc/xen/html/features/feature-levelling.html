<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="Revision 1" />
  <title>Feature Levelling</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<header>
<h1 class="title">Feature Levelling</h1>
<p class="author">Revision 1</p>
</header>
<nav id="TOC">
<ul>
<li><a href="#basics"><span class="toc-section-number">1</span> Basics</a></li>
<li><a href="#overview"><span class="toc-section-number">2</span> Overview</a></li>
<li><a href="#user-details"><span class="toc-section-number">3</span> User details</a></li>
<li><a href="#technical-details"><span class="toc-section-number">4</span> Technical details</a><ul>
<li><a href="#ability-to-control-cpuid"><span class="toc-section-number">4.1</span> Ability to control CPUID</a><ul>
<li><a href="#hvm"><span class="toc-section-number">4.1.1</span> HVM</a></li>
<li><a href="#pv"><span class="toc-section-number">4.1.2</span> PV</a></li>
<li><a href="#xen-forced-emulation-prefix"><span class="toc-section-number">4.1.3</span> Xen Forced Emulation Prefix</a></li>
<li><a href="#masking-and-override-msrs"><span class="toc-section-number">4.1.4</span> Masking and Override MSRs</a></li>
<li><a href="#cpuid-faulting"><span class="toc-section-number">4.1.5</span> CPUID Faulting</a></li>
</ul></li>
<li><a href="#compile-time"><span class="toc-section-number">4.2</span> Compile time</a></li>
<li><a href="#host-boot"><span class="toc-section-number">4.3</span> Host boot</a></li>
<li><a href="#domain-creation"><span class="toc-section-number">4.4</span> Domain creation</a></li>
</ul></li>
<li><a href="#limitations"><span class="toc-section-number">5</span> Limitations</a></li>
<li><a href="#testing"><span class="toc-section-number">6</span> Testing</a></li>
<li><a href="#known-issues-areas-for-improvement"><span class="toc-section-number">7</span> Known issues / Areas for improvement</a></li>
<li><a href="#references"><span class="toc-section-number">8</span> References</a></li>
<li><a href="#history"><span class="toc-section-number">9</span> History</a></li>
</ul>
</nav>

<h1 id="basics"><span class="header-section-number">1</span> Basics</h1>
<table style="width:97%;">
<colgroup>
<col style="width: 23%" />
<col style="width: 73%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: right;">Status:</td>
<td style="text-align: left;"><strong>Supported</strong></td>
</tr>
<tr class="even">
<td style="text-align: right;">Architecture:</td>
<td style="text-align: left;">x86</td>
</tr>
<tr class="odd">
<td style="text-align: right;">Component:</td>
<td style="text-align: left;">Hypervisor, toolstack, guest</td>
</tr>
</tbody>
</table>
<h1 id="overview"><span class="header-section-number">2</span> Overview</h1>
<p>On native hardware, a kernel will boot, detect features, typically optimise certain codepaths based on the available features, and expect the features to remain available until it shuts down.</p>
<p>The same expectation exists for virtual machines, and it is up to the hypervisor/toolstack to fulfill this expectation for the lifetime of the virtual machine, including across migrate/suspend/resume.</p>
<h1 id="user-details"><span class="header-section-number">3</span> User details</h1>
<p>Many factors affect the featureset which a VM may use:</p>
<ul>
<li>The CPU itself</li>
<li>The BIOS/firmware/microcode version and settings</li>
<li>The hypervisor version and command line settings</li>
<li>Further restrictions the toolstack chooses to apply</li>
</ul>
<p>A firmware or software upgrade might reduce the available set of features (e.g. Intel disabling TSX in a microcode update for certain Haswell/Broadwell processors), as may editing the settings.</p>
<p>It is unsafe to make any assumption about features remaining consistent across a host reboot. Xen recalculates all information from scratch each boot, and provides the information for the toolstack to consume.</p>
<p><code>xl</code> currently has no facilities to help the user collect appropriate feature information from relevant hosts and compute appropriate feature specifications for use in host or domain configurations. (<code>xl</code> being a single-host toolstack, it would in any case need external support for accessing remote hosts eg via ssh, in the form of automation software like GNU parallel or ansible.)</p>
<h1 id="technical-details"><span class="header-section-number">4</span> Technical details</h1>
<p>The <code>CPUID</code> instruction is used by software to query for features. In the virtualisation usecase, guest software should query Xen rather than hardware directly. However, <code>CPUID</code> is an unprivileged instruction which doesn’t fault, complicating the task of hiding hardware features from guests.</p>
<p>Important files:</p>
<ul>
<li>Hypervisor
<ul>
<li><code>xen/arch/x86/cpu/*.c</code></li>
<li><code>xen/arch/x86/cpuid.c</code></li>
<li><code>xen/include/asm-x86/cpuid-autogen.h</code></li>
<li><code>xen/include/public/arch-x86/cpufeatureset.h</code></li>
<li><code>xen/tools/gen-cpuid.py</code></li>
</ul></li>
<li><code>libxc</code>
<ul>
<li><code>tools/libxc/xc_cpuid_x86.c</code></li>
</ul></li>
</ul>
<h2 id="ability-to-control-cpuid"><span class="header-section-number">4.1</span> Ability to control CPUID</h2>
<h3 id="hvm"><span class="header-section-number">4.1.1</span> HVM</h3>
<p>HVM guests (using <code>Intel VT-x</code> or <code>AMD SVM</code>) will unconditionally exit to Xen on all <code>CPUID</code> instructions, allowing Xen full control over all information.</p>
<h3 id="pv"><span class="header-section-number">4.1.2</span> PV</h3>
<p>The <code>CPUID</code> instruction is unprivileged, so executing it in a PV guest will not trap, leaving Xen no direct ability to control the information returned.</p>
<h3 id="xen-forced-emulation-prefix"><span class="header-section-number">4.1.3</span> Xen Forced Emulation Prefix</h3>
<p>Xen-aware PV software can make use of the ‘Forced Emulation Prefix’</p>
<blockquote>
<p><code>ud2a; .ascii 'xen'; cpuid</code></p>
</blockquote>
<p>which Xen recognises as a deliberate attempt to get the fully-controlled <code>CPUID</code> information rather than the hardware-reported information. This only works with cooperative software.</p>
<h3 id="masking-and-override-msrs"><span class="header-section-number">4.1.4</span> Masking and Override MSRs</h3>
<p>AMD CPUs from the <code>K8</code> onwards support <em>Feature Override</em> MSRs, which allow direct control of the values returned for certain <code>CPUID</code> leaves. These MSRs allow any result to be returned, including the ability to advertise features which are not actually supported.</p>
<p>Intel CPUs between <code>Nehalem</code> and <code>SandyBridge</code> have differing numbers of <em>Feature Mask</em> MSRs, which are a simple AND-mask applied to all <code>CPUID</code> instructions requesting specific feature bitmap sets. The exact MSRs, and which feature bitmap sets they affect are hardware specific. These MSRs allow features to be hidden by clearing the appropriate bit in the mask, but does not allow unsupported features to be advertised.</p>
<h3 id="cpuid-faulting"><span class="header-section-number">4.1.5</span> CPUID Faulting</h3>
<p>Intel CPUs from <code>IvyBridge</code> onwards have <em>CPUID Faulting</em>, which allows Xen to cause <code>CPUID</code> instruction executed in PV guests to fault. This allows Xen full control over all information, exactly like HVM guests.</p>
<h2 id="compile-time"><span class="header-section-number">4.2</span> Compile time</h2>
<p>As some features depend on other features, it is important that, when disabling a certain feature, we disable all features which depend on it. This allows runtime logic to be simplified, by being able to rely on testing only the single appropriate feature, rather than the entire feature dependency chain.</p>
<p>To speed up runtime calculation of feature dependencies, the dependency chain is calculated and flattened by <code>xen/tools/gen-cpuid.py</code> to create <code>xen/include/asm-x86/cpuid-autogen.h</code> from <code>xen/include/public/arch-x86/cpufeatureset.h</code>, allowing the runtime code to disable all dependent features of a specific disabled feature in constant time.</p>
<h2 id="host-boot"><span class="header-section-number">4.3</span> Host boot</h2>
<p>As Xen boots, it will enumerate the features it can see. This is stored as the <em>raw_featureset</em>.</p>
<p>Errata checks and command line arguments are then taken into account to reduce the <em>raw_featureset</em> into the <em>host_featureset</em>, which is the set of features Xen uses. On hardware with masking/override MSRs, the default MSR values are picked from the <em>host_featureset</em>.</p>
<p>The <em>host_featureset</em> is then used to calculate the <em>pv_featureset</em> and <em>hvm_featureset</em>, which are the maximum featuresets Xen is willing to offer to PV and HVM guests respectively.</p>
<p>In addition, Xen will calculate how much control it has over non-cooperative PV <code>CPUID</code> instructions, storing this information as <em>levelling_caps</em>.</p>
<h2 id="domain-creation"><span class="header-section-number">4.4</span> Domain creation</h2>
<p>The toolstack can query each of the calculated featureset via <code>XEN_SYSCTL_get_cpu_featureset</code>, and query for the levelling caps via <code>XEN_SYSCTL_get_cpu_levelling_caps</code>.</p>
<p>These data should be used by the toolstack when choosing the eventual featureset to offer to the guest.</p>
<p>Once a featureset has been chosen, it is set (implicitly or explicitly) via <code>XEN_DOMCTL_set_cpuid</code>. Xen will clamp the toolstacks choice to the appropriate PV or HVM featureset. On hardware with masking/override MSRs, the guest cpuid policy is reflected in the MSRs, which are context switched with other vcpu state.</p>
<h1 id="limitations"><span class="header-section-number">5</span> Limitations</h1>
<p>A guest which ignores the provided feature information and manually probes for features will be able to find some of them. e.g. There is no way of forcibly preventing a guest from using 1GB superpages if the hardware supports it.</p>
<p>Some information simply cannot be hidden from guests. There is no way to control certain behaviour such as the hardware MXCSR_MASK or x87 FPU exception behaviour.</p>
<h1 id="testing"><span class="header-section-number">6</span> Testing</h1>
<p>Feature levelling is a very wide area, and used all over the hypervisor. Please ask on xen-devel for help identifying more specific tests which could be of use.</p>
<h1 id="known-issues-areas-for-improvement"><span class="header-section-number">7</span> Known issues / Areas for improvement</h1>
<p>The feature querying and levelling functions should exposed in a convenient-to-use way by <code>xl</code>.</p>
<p>Xen currently has no concept of per-{socket,core,thread} CPUID information. As a result, details such as APIC IDs, topology and cache information do not match real hardware, and do not match the documented expectations in the Intel and AMD system manuals.</p>
<p>The CPU feature flags are the only information which the toolstack has a sensible interface for querying and levelling. Other information in the CPUID policy is important and should be levelled (e.g. maxphysaddr).</p>
<p>The CPUID policy is currently regenerated from scratch by the receiving side, once memory and vcpu content has been restored. This means that the receiving Xen cannot verify the memory/vcpu content against the CPUID policy, and can end up running a guest which will subsequently crash. The CPUID policy should be at the head of the migration stream.</p>
<p>MSRs are another source of features for guests. There is no general provision for controlling the available MSRs. E.g. 64bit versions of Windows notice changes in IA32_MISC_ENABLE, and suffer a BSOD 0x109 (Critical Structure Corruption)</p>
<h1 id="references"><span class="header-section-number">8</span> References</h1>
<p><a href="http://www.intel.co.uk/content/dam/www/public/us/en/documents/application-notes/virtualization-technology-flexmigration-application-note.pdf">Intel Flexmigration</a></p>
<p><a href="http://developer.amd.com/wordpress/media/2012/10/43781-3.00-PUB_Live-Virtual-Machine-Migration-on-AMD-processors.pdf">AMD Extended Migration Technology</a></p>
<h1 id="history"><span class="header-section-number">9</span> History</h1>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 12%" />
<col style="width: 12%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Date</th>
<th>Revision</th>
<th style="text-align: left;">Version</th>
<th style="text-align: left;">Notes</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">2016-05-31</td>
<td>1</td>
<td style="text-align: left;">Xen 4.7</td>
<td style="text-align: left;">Document written</td>
</tr>
</tbody>
</table>
</body>
</html>
