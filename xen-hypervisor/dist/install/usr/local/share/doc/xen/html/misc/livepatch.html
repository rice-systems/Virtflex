<h1>Xen Live Patching Design v1</h1>

<h2>Rationale</h2>

<p>A mechanism is required to binarily patch the running hypervisor with new
opcodes that have come about due to primarily security updates.</p>

<p>This document describes the design of the API that would allow us to
upload to the hypervisor binary patches.</p>

<p>The document is split in four sections:</p>

<ul>
<li>Detailed descriptions of the problem statement.</li>
<li>Design of the data structures.</li>
<li>Design of the hypercalls.</li>
<li>Implementation notes that should be taken into consideration.</li>
</ul>

<h2>Glossary</h2>

<ul>
<li>splice - patch in the binary code with new opcodes</li>
<li>trampoline - a jump to a new instruction.</li>
<li>payload - telemetries of the old code along with binary blob of the new
function (if needed).</li>
<li>reloc - telemetries contained in the payload to construct proper trampoline.</li>
</ul>

<h2>History</h2>

<p>The document has gone under various reviews and only covers v1 design.</p>

<p>The end of the document has a section titled <code>Not Yet Done</code> which
outlines ideas and design for the future version of this work.</p>

<h2>Multiple ways to patch</h2>

<p>The mechanism needs to be flexible to patch the hypervisor in multiple ways
and be as simple as possible. The compiled code is contiguous in memory with
no gaps - so we have no luxury of 'moving' existing code and must either
insert a trampoline to the new code to be executed - or only modify in-place
the code if there is sufficient space. The placement of new code has to be done
by hypervisor and the virtual address for the new code is allocated dynamically.</p>

<p>This implies that the hypervisor must compute the new offsets when splicing
in the new trampoline code. Where the trampoline is added (inside
the function we are patching or just the callers?) is also important.</p>

<p>To lessen the amount of code in hypervisor, the consumer of the API
is responsible for identifying which mechanism to employ and how many locations
to patch. Combinations of modifying in-place code, adding trampoline, etc
has to be supported. The API should allow read/write any memory within
the hypervisor virtual address space.</p>

<p>We must also have a mechanism to query what has been applied and a mechanism
to revert it if needed.</p>

<h2>Workflow</h2>

<p>The expected workflows of higher-level tools that manage multiple patches
on production machines would be:</p>

<ul>
<li>The first obvious task is loading all available / suggested
hotpatches when they are available.</li>
<li>Whenever new hotpatches are installed, they should be loaded too.</li>
<li>One wants to query which modules have been loaded at runtime.</li>
<li>If unloading is deemed safe (see unloading below), one may want to
support a workflow where a specific hotpatch is marked as bad and
unloaded.</li>
</ul>

<h2>Patching code</h2>

<p>The first mechanism to patch that comes in mind is in-place replacement.
That is replace the affected code with new code. Unfortunately the x86
ISA is variable size which places limits on how much space we have available
to replace the instructions. That is not a problem if the change is smaller
than the original opcode and we can fill it with nops. Problems will
appear if the replacement code is longer.</p>

<p>The second mechanism is by ti replace the call or jump to the
old function with the address of the new function.</p>

<p>A third mechanism is to add a jump to the new function at the
start of the old function. N.B. The Xen hypervisor implements the third
mechanism. See <code>Trampoline (e9 opcode)</code> section for more details.</p>

<h3>Example of trampoline and in-place splicing</h3>

<p>As example we will assume the hypervisor does not have XSA-132 (see
<a href="http://xenbits.xen.org/gitweb/?p=xen.git;a=commitdiff;h=4ff3449f0e9d175ceb9551d3f2aecb59273f639d">domctl/sysctl: don't leak hypervisor stack to toolstacks</a>)
and we would like to binary patch the hypervisor with it. The original code
looks as so:</p>

<pre><code>48 89 e0                  mov    %rsp,%rax
48 25 00 80 ff ff         and    $0xffffffffffff8000,%rax
</code></pre>

<p>while the new patched hypervisor would be:</p>

<pre><code>48 c7 45 b8 00 00 00 00   movq   $0x0,-0x48(%rbp)
48 c7 45 c0 00 00 00 00   movq   $0x0,-0x40(%rbp)
48 c7 45 c8 00 00 00 00   movq   $0x0,-0x38(%rbp)
48 89 e0                  mov    %rsp,%rax
48 25 00 80 ff ff         and    $0xffffffffffff8000,%rax
</code></pre>

<p>This is inside the arch_do_domctl. This new change adds 21 extra
bytes of code which alters all the offsets inside the function. To alter
these offsets and add the extra 21 bytes of code we might not have enough
space in .text to squeeze this in.</p>

<p>As such we could simplify this problem by only patching the site
which calls arch_do_domctl:</p>

<pre><code>do_domctl:
e8 4b b1 05 00          callq  ffff82d08015fbb9 &lt;arch_do_domctl&gt;
</code></pre>

<p>with a new address for where the new <code>arch_do_domctl</code> would be (this
area would be allocated dynamically).</p>

<p>Astute readers will wonder what we need to do if we were to patch <code>do_domctl</code>
- which is not called directly by hypervisor but on behalf of the guests via
the <code>compat_hypercall_table</code> and <code>hypercall_table</code>.  Patching the offset in
<code>hypercall_table</code> for <code>do_domctl</code>:</p>

<pre><code>ffff82d08024d490:   79 30
ffff82d08024d492:   10 80 d0 82 ff ff
</code></pre>

<p>with the new address where the new <code>do_domctl</code> is possible. The other
place where it is used is in <code>hvm_hypercall64_table</code> which would need
to be patched in a similar way. This would require an in-place splicing
of the new virtual address of <code>arch_do_domctl</code>.</p>

<p>In summary this example patched the callee of the affected function by</p>

<ul>
<li>Allocating memory for the new code to live in,</li>
<li>Changing the virtual address in all the functions which called the old
code (computing the new offset, patching the callq with a new callq).</li>
<li>Changing the function pointer tables with the new virtual address of
the function (splicing in the new virtual address). Since this table
resides in the .rodata section we would need to temporarily change the
page table permissions during this part.</li>
</ul>

<p>However it has drawbacks - the safety checks which have to make sure
the function is not on the stack - must also check every caller. For some
patches this could mean - if there were an sufficient large amount of
callers - that we would never be able to apply the update.</p>

<p>Having the patching done at predetermined instances where the stacks
are not deep mostly solves this problem.</p>

<h3>Example of different trampoline patching.</h3>

<p>An alternative mechanism exists where we can insert a trampoline in the
existing function to be patched to jump directly to the new code. This
lessens the locations to be patched to one but it puts pressure on the
CPU branching logic (I-cache, but it is just one unconditional jump).</p>

<p>For this example we will assume that the hypervisor has not been compiled with
XSA-125 (see
<a href="http://xenbits.xen.org/gitweb/?p=xen.git;a=commitdiff;h=fe2e079f642effb3d24a6e1a7096ef26e691d93e">pre-fill structures for certain HYPERVISOR_xen_version sub-ops</a>)
which mem-sets an structure in <code>xen_version</code> hypercall. This function is not
called <strong>anywhere</strong> in the hypervisor (it is called by the guest) but
referenced in the <code>compat_hypercall_table</code> and <code>hypercall_table</code> (and
indirectly called from that). Patching the offset in <code>hypercall_table</code> for the
old <code>do_xen_version</code>:</p>

<pre><code>ffff82d08024b270 &lt;hypercall_table&gt;:
...
ffff82d08024b2f8:   9e 2f 11 80 d0 82 ff ff
</code></pre>

<p>with the new address where the new <code>do_xen_version</code> is possible. The other
place where it is used is in <code>hvm_hypercall64_table</code> which would need
to be patched in a similar way. This would require an in-place splicing
of the new virtual address of <code>do_xen_version</code>.</p>

<p>An alternative solution would be to patch insert a trampoline in the
old <code>do_xen_version</code> function to directly jump to the new <code>do_xen_version</code>:</p>

<pre><code>ffff82d080112f9e do_xen_version:
ffff82d080112f9e:       48 c7 c0 da ff ff ff    mov    $0xffffffffffffffda,%rax
ffff82d080112fa5:       83 ff 09                cmp    $0x9,%edi
ffff82d080112fa8:       0f 87 24 05 00 00       ja     ffff82d0801134d2 ; do_xen_version+0x534
</code></pre>

<p>with:</p>

<pre><code>ffff82d080112f9e do_xen_version:
ffff82d080112f9e:       e9 XX YY ZZ QQ          jmpq   [new do_xen_version]
</code></pre>

<p>which would lessen the amount of patching to just one location.</p>

<p>In summary this example patched the affected function to jump to the
new replacement function which required:</p>

<ul>
<li>Allocating memory for the new code to live in,</li>
<li>Inserting trampoline with new offset in the old function to point to the
new function.</li>
<li>Optionally we can insert in the old function a trampoline jump to an function
providing an BUG_ON to catch errant code.</li>
</ul>

<p>The disadvantage of this are that the unconditional jump will consume a small
I-cache penalty. However the simplicity of the patching and higher chance
of passing safety checks make this a worthwhile option.</p>

<p>This patching has a similar drawback as inline patching - the safety
checks have to make sure the function is not on the stack. However
since we are replacing at a higher level (a full function as opposed
to various offsets within functions) the checks are simpler.</p>

<p>Having the patching done at predetermined instances where the stacks
are not deep mostly solves this problem as well.</p>

<h3>Security</h3>

<p>With this method we can re-write the hypervisor - and as such we <strong>MUST</strong> be
diligent in only allowing certain guests to perform this operation.</p>

<p>Furthermore with SecureBoot or tboot, we <strong>MUST</strong> also verify the signature
of the payload to be certain it came from a trusted source and integrity
was intact.</p>

<p>As such the hypercall <strong>MUST</strong> support an XSM policy to limit what the guest
is allowed to invoke. If the system is booted with signature checking the
signature checking will be enforced.</p>

<h2>Design of payload format</h2>

<p>The payload <strong>MUST</strong> contain enough data to allow us to apply the update
and also safely reverse it. As such we <strong>MUST</strong> know:</p>

<ul>
<li>The locations in memory to be patched. This can be determined dynamically
via symbols or via virtual addresses.</li>
<li>The new code that will be patched in.</li>
</ul>

<p>This binary format can be constructed using an custom binary format but
there are severe disadvantages of it:</p>

<ul>
<li>The format might need to be changed and we need an mechanism to accommodate
that.</li>
<li>It has to be platform agnostic.</li>
<li>Easily constructed using existing tools.</li>
</ul>

<p>As such having the payload in an ELF file is the sensible way. We would be
carrying the various sets of structures (and data) in the ELF sections under
different names and with definitions.</p>

<p>Note that every structure has padding. This is added so that the hypervisor
can re-use those fields as it sees fit.</p>

<p>Earlier design attempted to ineptly explain the relations of the ELF sections
to each other without using proper ELF mechanism (sh_info, sh_link, data
structures using Elf types, etc). This design will explain the structures
and how they are used together and not dig in the ELF format - except mention
that the section names should match the structure names.</p>

<p>The Xen Live Patch payload is a relocatable ELF binary. A typical binary would have:</p>

<ul>
<li>One or more .text sections.</li>
<li>Zero or more read-only data sections.</li>
<li>Zero or more data sections.</li>
<li>Relocations for each of these sections.</li>
</ul>

<p>It may also have some architecture-specific sections. For example:</p>

<ul>
<li>Alternatives instructions.</li>
<li>Bug frames.</li>
<li>Exception tables.</li>
<li>Relocations for each of these sections.</li>
</ul>

<p>The Xen Live Patch core code loads the payload as a standard ELF binary, relocates it
and handles the architecture-specifc sections as needed. This process is much
like what the Linux kernel module loader does.</p>

<p>The payload contains at least three sections:</p>

<ul>
<li><code>.livepatch.funcs</code> - which is an array of livepatch_func structures.</li>
<li><code>.livepatch.depends</code> - which is an ELF Note that describes what the payload
depends on. <strong>MUST</strong> have one.</li>
<li><code>.note.gnu.build-id</code> - the build-id of this payload. <strong>MUST</strong> have one.</li>
</ul>

<h3>.livepatch.funcs</h3>

<p>The <code>.livepatch.funcs</code> contains an array of livepatch_func structures
which describe the functions to be patched:</p>

<pre><code>struct livepatch_func {
    const char *name;
    void *new_addr;
    void *old_addr;
    uint32_t new_size;
    uint32_t old_size;
    uint8_t version;
    uint8_t opaque[31];
};
</code></pre>

<p>The size of the structure is 64 bytes on 64-bit hypervisors. It will be
52 on 32-bit hypervisors.</p>

<ul>
<li><code>name</code> is the symbol name of the old function. Only used if <code>old_addr</code> is
zero, otherwise will be used during dynamic linking (when hypervisor loads
the payload).</li>
<li><code>old_addr</code> is the address of the function to be patched and is filled in at
payload generation time if hypervisor function address is known. If unknown,
the value <em>MUST</em> be zero and the hypervisor will attempt to resolve the
address.</li>
<li><code>new_addr</code> can either have a non-zero value or be zero.
<ul>
<li>If there is a non-zero value, then it is the address of the function that
is replacing the old function and the address is recomputed during
relocation.  The value <strong>MUST</strong> be the address of the new function in the
payload file.</li>
<li>If the value is zero, then we NOPing out at the <code>old_addr</code> location
<code>new_size</code> bytes.</li>
</ul></li>
<li><code>old_size</code> contains the sizes of the respective <code>old_addr</code> function in
bytes.  The value of <code>old_size</code> <strong>MUST</strong> not be zero.</li>
<li><code>new_size</code> depends on what <code>new_addr</code> contains:
<ul>
<li>If <code>new_addr</code> contains an non-zero value, then <code>new_size</code> has the size of
the new function (which will replace the one at <code>old_addr</code>) in bytes.</li>
<li>If the value of <code>new_addr</code> is zero then <code>new_size</code> determines how many
instruction bytes to NOP (up to opaque size modulo smallest platform
instruction - 1 byte x86 and 4 bytes on ARM).</li>
</ul></li>
<li><code>version</code> is to be one.</li>
<li><code>opaque</code> <strong>MUST</strong> be zero.</li>
</ul>

<p>The size of the <code>livepatch_func</code> array is determined from the ELF section
size.</p>

<p>When applying the patch the hypervisor iterates over each <code>livepatch_func</code>
structure and the core code inserts a trampoline at <code>old_addr</code> to <code>new_addr</code>.
The <code>new_addr</code> is altered when the ELF payload is loaded.</p>

<p>When reverting a patch, the hypervisor iterates over each <code>livepatch_func</code>
and the core code copies the data from the undo buffer (private internal copy)
to <code>old_addr</code>.</p>

<p>It optionally may contain the address of functions to be called right before
being applied and after being reverted:</p>

<ul>
<li><code>.livepatch.hooks.load</code> - an array of function pointers.</li>
<li><code>.livepatch.hooks.unload</code> - an array of function pointers.</li>
</ul>

<h3>Example of .livepatch.funcs</h3>

<p>A simple example of what a payload file can be:</p>

<pre><code>/* MUST be in sync with hypervisor. */
struct livepatch_func {
    const char *name;
    void *new_addr;
    void *old_addr;
    uint32_t new_size;
    uint32_t old_size;
    uint8_t version;
    uint8_t pad[31];
};

/* Our replacement function for xen_extra_version. */
const char *xen_hello_world(void)
{
    return "Hello World";
}

static unsigned char patch_this_fnc[] = "xen_extra_version";

struct livepatch_func livepatch_hello_world = {
    .version = LIVEPATCH_PAYLOAD_VERSION,
    .name = patch_this_fnc,
    .new_addr = xen_hello_world,
    .old_addr = (void *)0xffff82d08013963c, /* Extracted from xen-syms. */
    .new_size = 13, /* To be be computed by scripts. */
    .old_size = 13, /* -----------""---------------  */
} __attribute__((__section__(".livepatch.funcs")));
</code></pre>

<p>Code must be compiled with <code>-fPIC</code>.</p>

<h3>.livepatch.hooks.load and .livepatch.hooks.unload</h3>

<p>This section contains an array of function pointers to be executed
before payload is being applied (.livepatch.funcs) or after reverting
the payload. This is useful to prepare data structures that need to
be modified patching.</p>

<p>Each entry in this array is eight bytes.</p>

<p>The type definition of the function are as follow:</p>

<pre><code>typedef void (*livepatch_loadcall_t)(void);
typedef void (*livepatch_unloadcall_t)(void);
</code></pre>

<h3>.livepatch.depends and .note.gnu.build-id</h3>

<p>To support dependencies checking and safe loading (to load the
appropiate payload against the right hypervisor) there is a need
to embbed an build-id dependency.</p>

<p>This is done by the payload containing an section <code>.livepatch.depends</code>
which follows the format of an ELF Note. The contents of this
(name, and description) are specific to the linker utilized to
build the hypevisor and payload.</p>

<p>If GNU linker is used then the name is <code>GNU</code> and the description
is a NT_GNU_BUILD_ID type ID. The description can be an SHA1
checksum, MD5 checksum or any unique value.</p>

<p>The size of these structures varies with the <code>--build-id</code> linker option.</p>

<h2>Hypercalls</h2>

<p>We will employ the sub operations of the system management hypercall (sysctl).
There are to be four sub-operations:</p>

<ul>
<li>upload the payloads.</li>
<li>listing of payloads summary uploaded and their state.</li>
<li>getting an particular payload summary and its state.</li>
<li>command to apply, delete, or revert the payload.</li>
</ul>

<p>Most of the actions are asynchronous therefore the caller is responsible
to verify that it has been applied properly by retrieving the summary of it
and verifying that there are no error codes associated with the payload.</p>

<p>We <strong>MUST</strong> make some of them asynchronous due to the nature of patching
it requires every physical CPU to be lock-step with each other.
The patching mechanism while an implementation detail, is not an short
operation and as such the design <strong>MUST</strong> assume it will be an long-running
operation.</p>

<p>The sub-operations will spell out how preemption is to be handled (if at all).</p>

<p>Furthermore it is possible to have multiple different payloads for the same
function. As such an unique name per payload has to be visible to allow proper manipulation.</p>

<p>The hypercall is part of the <code>xen_sysctl</code>. The top level structure contains
one uint32_t to determine the sub-operations and one padding field which
<em>MUST</em> always be zero.</p>

<pre><code>struct xen_sysctl_livepatch_op {
    uint32_t cmd;                   /* IN: XEN_SYSCTL_LIVEPATCH_*. */
    uint32_t pad;                   /* IN: Always zero. */
    union {
          ... see below ...
        } u;
};
</code></pre>

<p>while the rest of hypercall specific structures are part of the this structure.</p>

<h3>Basic type: struct xen_livepatch_name</h3>

<p>Most of the hypercalls employ an shared structure called <code>struct xen_livepatch_name</code>
which contains:</p>

<ul>
<li><code>name</code> - pointer where the string for the name is located.</li>
<li><code>size</code> - the size of the string</li>
<li><code>pad</code> - padding - to be zero.</li>
</ul>

<p>The structure is as follow:</p>

<pre><code>/*
 *  Uniquely identifies the payload.  Should be human readable.
 * Includes the NUL terminator
 */
#define XEN_LIVEPATCH_NAME_SIZE 128
struct xen_livepatch_name {
    XEN_GUEST_HANDLE_64(char) name;         /* IN, pointer to name. */
    uint16_t size;                          /* IN, size of name. May be upto
                                               XEN_LIVEPATCH_NAME_SIZE. */
    uint16_t pad[3];                        /* IN: MUST be zero. */
};
</code></pre>

<h3>XEN_SYSCTL_LIVEPATCH_UPLOAD (0)</h3>

<p>Upload a payload to the hypervisor. The payload is verified
against basic checks and if there are any issues the proper return code
will be returned. The payload is not applied at this time - that is
controlled by <em>XEN_SYSCTL_LIVEPATCH_ACTION</em>.</p>

<p>The caller provides:</p>

<ul>
<li>A <code>struct xen_livepatch_name</code> called <code>name</code> which has the unique name.</li>
<li><code>size</code> the size of the ELF payload (in bytes).</li>
<li><code>payload</code> the virtual address of where the ELF payload is.</li>
</ul>

<p>The <code>name</code> could be an UUID that stays fixed forever for a given
payload. It can be embedded into the ELF payload at creation time
and extracted by tools.</p>

<p>The return value is zero if the payload was succesfully uploaded.
Otherwise an -XEN_EXX return value is provided. Duplicate <code>name</code> are not supported.</p>

<p>The <code>payload</code> is the ELF payload as mentioned in the <code>Payload format</code> section.</p>

<p>The structure is as follow:</p>

<pre><code>struct xen_sysctl_livepatch_upload {
    xen_livepatch_name_t name;          /* IN, name of the patch. */
    uint64_t size;                      /* IN, size of the ELF file. */
    XEN_GUEST_HANDLE_64(uint8) payload; /* IN: ELF file. */
};
</code></pre>

<h3>XEN_SYSCTL_LIVEPATCH_GET (1)</h3>

<p>Retrieve an status of an specific payload. This caller provides:</p>

<ul>
<li>A <code>struct xen_livepatch_name</code> called <code>name</code> which has the unique name.</li>
<li>A <code>struct xen_livepatch_status</code> structure. The member values will
be over-written upon completion.</li>
</ul>

<p>Upon completion the <code>struct xen_livepatch_status</code> is updated.</p>

<ul>
<li><code>status</code> - indicates the current status of the payload:
<ul>
<li><em>LIVEPATCH_STATUS_CHECKED</em> (1) loaded and the ELF payload safety checks passed.</li>
<li><em>LIVEPATCH_STATUS_APPLIED</em> (2) loaded, checked, and applied.</li>
<li>No other value is possible.</li>
</ul></li>
<li><code>rc</code> - -XEN_EXX type errors encountered while performing the last
LIVEPATCH_ACTION_* operation. The normal values can be zero or -XEN_EAGAIN which
respectively mean: success or operation in progress. Other values
imply an error occurred. If there is an error in <code>rc</code>, <code>status</code> will <strong>NOT</strong>
have changed.</li>
</ul>

<p>The return value of the hypercall is zero on success and -XEN_EXX on failure.
(Note that the <code>rc</code> value can be different from the return value, as in
rc=-XEN_EAGAIN and return value can be 0).</p>

<p>For example, supposing there is an payload:</p>

<pre><code>status: LIVEPATCH_STATUS_CHECKED
rc: 0
</code></pre>

<p>We apply an action - LIVEPATCH_ACTION_REVERT - to revert it (which won't work
as we have not even applied it. Afterwards we will have:</p>

<pre><code>status: LIVEPATCH_STATUS_CHECKED
rc: -XEN_EINVAL
</code></pre>

<p>It has failed but it remains loaded.</p>

<p>This operation is synchronous and does not require preemption.</p>

<p>The structure is as follow:</p>

<pre><code>struct xen_livepatch_status {
#define LIVEPATCH_STATUS_CHECKED      1
#define LIVEPATCH_STATUS_APPLIED      2
    uint32_t state;                 /* OUT: LIVEPATCH_STATE_*. */
    int32_t rc;                     /* OUT: 0 if no error, otherwise -XEN_EXX. */
};

struct xen_sysctl_livepatch_get {
    xen_livepatch_name_t name;      /* IN, the name of the payload. */
    xen_livepatch_status_t status;  /* IN/OUT: status of the payload. */
};
</code></pre>

<h3>XEN_SYSCTL_LIVEPATCH_LIST (2)</h3>

<p>Retrieve an array of abbreviated status and names of payloads that are loaded in the
hypervisor.</p>

<p>The caller provides:</p>

<ul>
<li><code>version</code>. Version of the payload. Caller should re-use the field provided by
the hypervisor. If the value differs the data is stale.</li>
<li><code>idx</code> Index iterator. The index into the hypervisor's payload count. It is
recommended that on first invocation zero be used so that <code>nr</code> (which the
hypervisor will update with the remaining payload count) be provided.
Also the hypervisor will provide <code>version</code> with the most current value.</li>
<li><code>nr</code> The max number of entries to populate. Can be zero which will result
in the hypercall being a probing one and return the number of payloads
(and update the <code>version</code>).</li>
<li><code>pad</code> - <em>MUST</em> be zero.</li>
<li><code>status</code> Virtual address of where to write <code>struct xen_livepatch_status</code>
structures. Caller <em>MUST</em> allocate up to <code>nr</code> of them.</li>
<li><code>name</code> - Virtual address of where to write the unique name of the payload.
Caller <em>MUST</em> allocate up to <code>nr</code> of them. Each <em>MUST</em> be of
<strong>XEN_LIVEPATCH_NAME_SIZE</strong> size. Note that <strong>XEN_LIVEPATCH_NAME_SIZE</strong> includes
the NUL terminator.</li>
<li><code>len</code> - Virtual address of where to write the length of each unique name
of the payload. Caller <em>MUST</em> allocate up to <code>nr</code> of them. Each <em>MUST</em> be
of sizeof(uint32_t) (4 bytes).</li>
</ul>

<p>If the hypercall returns an positive number, it is the number (upto <code>nr</code>
provided to the hypercall) of the payloads returned, along with <code>nr</code> updated
with the number of remaining payloads, <code>version</code> updated (it may be the same
across hypercalls - if it varies the data is stale and further calls could
fail). The <code>status</code>, <code>name</code>, and <code>len</code> are updated at their designed index
value (<code>idx</code>) with the returned value of data.</p>

<p>If the hypercall returns -XEN_E2BIG the <code>nr</code> is too big and should be
lowered.</p>

<p>If the hypercall returns an zero value there are no more payloads.</p>

<p>Note that due to the asynchronous nature of hypercalls the control domain might
have added or removed a number of payloads making this information stale. It is
the responsibility of the toolstack to use the <code>version</code> field to check
between each invocation. if the version differs it should discard the stale
data and start from scratch. It is OK for the toolstack to use the new
<code>version</code> field.</p>

<p>The <code>struct xen_livepatch_status</code> structure contains an status of payload which includes:</p>

<ul>
<li><code>status</code> - indicates the current status of the payload:
<ul>
<li><em>LIVEPATCH_STATUS_CHECKED</em> (1) loaded and the ELF payload safety checks passed.</li>
<li><em>LIVEPATCH_STATUS_APPLIED</em> (2) loaded, checked, and applied.</li>
<li>No other value is possible.</li>
</ul></li>
<li><code>rc</code> - -XEN_EXX type errors encountered while performing the last
LIVEPATCH_ACTION_* operation. The normal values can be zero or -XEN_EAGAIN which
respectively mean: success or operation in progress. Other values
imply an error occurred. If there is an error in <code>rc</code>, <code>status</code> will <strong>NOT</strong>
have changed.</li>
</ul>

<p>The structure is as follow:</p>

<pre><code>struct xen_sysctl_livepatch_list {
    uint32_t version;                       /* OUT: Hypervisor stamps value.
                                               If varies between calls, we are
                                               getting stale data. */
    uint32_t idx;                           /* IN: Index into hypervisor list. */
    uint32_t nr;                            /* IN: How many status, names, and len
                                               should be filled out. Can be zero to get
                                               amount of payloads and version.
                                               OUT: How many payloads left. */
    uint32_t pad;                           /* IN: Must be zero. */
    XEN_GUEST_HANDLE_64(xen_livepatch_status_t) status;  /* OUT. Must have enough
                                               space allocate for nr of them. */
    XEN_GUEST_HANDLE_64(char) id;           /* OUT: Array of names. Each member
                                               MUST XEN_LIVEPATCH_NAME_SIZE in size.
                                               Must have nr of them. */
    XEN_GUEST_HANDLE_64(uint32) len;        /* OUT: Array of lengths of name's.
                                               Must have nr of them. */
};
</code></pre>

<h3>XEN_SYSCTL_LIVEPATCH_ACTION (3)</h3>

<p>Perform an operation on the payload structure referenced by the <code>name</code> field.
The operation request is asynchronous and the status should be retrieved
by using either <strong>XEN_SYSCTL_LIVEPATCH_GET</strong> or <strong>XEN_SYSCTL_LIVEPATCH_LIST</strong> hypercall.</p>

<p>The caller provides:</p>

<ul>
<li>A <code>struct xen_livepatch_name</code> <code>name</code> containing the unique name.</li>
<li><code>cmd</code> The command requested:
<ul>
<li><em>LIVEPATCH_ACTION_UNLOAD</em> (1) Unload the payload.
Any further hypercalls against the <code>name</code> will result in failure unless
<strong>XEN_SYSCTL_LIVEPATCH_UPLOAD</strong> hypercall is perfomed with same <code>name</code>.</li>
<li><em>LIVEPATCH_ACTION_REVERT</em> (2) Revert the payload. If the operation takes
more time than the upper bound of time the <code>rc</code> in <code>xen_livepatch_status</code>
retrieved via <strong>XEN_SYSCTL_LIVEPATCH_GET</strong> will be -XEN_EBUSY.</li>
<li><em>LIVEPATCH_ACTION_APPLY</em> (3) Apply the payload. If the operation takes
more time than the upper bound of time the <code>rc</code> in <code>xen_livepatch_status</code>
retrieved via <strong>XEN_SYSCTL_LIVEPATCH_GET</strong> will be -XEN_EBUSY.</li>
<li><em>LIVEPATCH_ACTION_REPLACE</em> (4) Revert all applied payloads and apply this
payload. If the operation takes more time than the upper bound of time
the <code>rc</code> in <code>xen_livepatch_status</code> retrieved via <strong>XEN_SYSCTL_LIVEPATCH_GET</strong>
will be -XEN_EBUSY.</li>
</ul></li>
<li><code>time</code> The upper bound of time (ns) the cmd should take. Zero means to use
the hypervisor default. If within the time the operation does not succeed
the operation would go in error state.</li>
<li><code>pad</code> - <em>MUST</em> be zero.</li>
</ul>

<p>The return value will be zero unless the provided fields are incorrect.</p>

<p>The structure is as follow:</p>

<pre><code>#define LIVEPATCH_ACTION_UNLOAD  1
#define LIVEPATCH_ACTION_REVERT  2
#define LIVEPATCH_ACTION_APPLY   3
#define LIVEPATCH_ACTION_REPLACE 4
struct xen_sysctl_livepatch_action {
    xen_livepatch_name_t name;              /* IN, name of the patch. */
    uint32_t cmd;                           /* IN: LIVEPATCH_ACTION_* */
    uint32_t time;                          /* IN: If zero then uses */
                                            /* hypervisor default. */
                                            /* Or upper bound of time (ns) */
                                            /* for operation to take. */
};
</code></pre>

<h2>State diagrams of LIVEPATCH_ACTION commands.</h2>

<p>There is a strict ordering state of what the commands can be.
The LIVEPATCH_ACTION prefix has been dropped to easy reading and
does not include the LIVEPATCH_STATES:</p>

<pre><code>             /-&gt;\
             \  /
UNLOAD &lt;--- CHECK ---&gt; REPLACE|APPLY --&gt; REVERT --\
               \                                  |
                \-------------------&lt;-------------/
</code></pre>

<h2>State transition table of LIVEPATCH_ACTION commands and LIVEPATCH_STATUS.</h2>

<p>Note that:</p>

<ul>
<li>The CHECKED state is the starting one achieved with <em>XEN_SYSCTL_LIVEPATCH_UPLOAD</em> hypercall.</li>
<li>The REVERT operation on success will automatically move to the CHECKED state.</li>
<li>There are two STATES: CHECKED and APPLIED.</li>
<li>There are four actions (aka commands): APPLY, REPLACE, REVERT, and UNLOAD.</li>
</ul>

<p>The state transition table of valid states and action states:</p>

<pre><code>+---------+---------+--------------------------------+-------+--------+
| ACTION  | Current | Result                         |   Next STATE:  |
| ACTION  | STATE   |                                |CHECKED|APPLIED |
+---------+----------+-------------------------------+-------+--------+
| UNLOAD  | CHECKED | Unload payload. Always works.  |       |        |
|         |         | No next states.                |       |        |
+---------+---------+--------------------------------+-------+--------+
| APPLY   | CHECKED | Apply payload (success).       |       |   x    |
+---------+---------+--------------------------------+-------+--------+
| APPLY   | CHECKED | Apply payload (error|timeout)  |   x   |        |
+---------+---------+--------------------------------+-------+--------+
| REPLACE | CHECKED | Revert payloads and apply new  |       |   x    |
|         |         | payload with success.          |       |        |
+---------+---------+--------------------------------+-------+--------+
| REPLACE | CHECKED | Revert payloads and apply new  |   x   |        |
|         |         | payload with error.            |       |        |
+---------+---------+--------------------------------+-------+--------+
| REVERT  | APPLIED | Revert payload (success).      |   x   |        |
+---------+---------+--------------------------------+-------+--------+
| REVERT  | APPLIED | Revert payload (error|timeout) |       |   x    |
+---------+---------+--------------------------------+-------+--------+
</code></pre>

<p>All the other state transitions are invalid.</p>

<h2>Sequence of events.</h2>

<p>The normal sequence of events is to:</p>

<ol>
<li><em>XEN_SYSCTL_LIVEPATCH_UPLOAD</em> to upload the payload. If there are errors <em>STOP</em> here.</li>
<li><em>XEN_SYSCTL_LIVEPATCH_GET</em> to check the <code>-&gt;rc</code>. If <em>-XEN_EAGAIN</em> spin. If zero go to next step.</li>
<li><em>XEN_SYSCTL_LIVEPATCH_ACTION</em> with <em>LIVEPATCH_ACTION_APPLY</em> to apply the patch.</li>
<li><em>XEN_SYSCTL_LIVEPATCH_GET</em> to check the <code>-&gt;rc</code>. If in <em>-XEN_EAGAIN</em> spin. If zero exit with success.</li>
</ol>

<h2>Addendum</h2>

<p>Implementation quirks should not be discussed in a design document.</p>

<p>However these observations can provide aid when developing against this
document.</p>

<h3>Alternative assembler</h3>

<p>Alternative assembler is a mechanism to use different instructions depending
on what the CPU supports. This is done by providing multiple streams of code
that can be patched in - or if the CPU does not support it - padded with
<code>nop</code> operations. The alternative assembler macros cause the compiler to
expand the code to place a most generic code in place - emit a special
ELF .section header to tag this location. During run-time the hypervisor
can leave the areas alone or patch them with an better suited opcodes.</p>

<p>Note that patching functions that copy to or from guest memory requires
to support alternative support. For example this can be due to SMAP
(specifically <em>stac</em> and <em>clac</em> operations) which is enabled on Broadwell
and later architectures. It may be related to other alternative instructions.</p>

<h3>When to patch</h3>

<p>During the discussion on the design two candidates bubbled where
the call stack for each CPU would be deterministic. This would
minimize the chance of the patch not being applied due to safety
checks failing. Safety checks such as not patching code which
is on the stack - which can lead to corruption.</p>

<h4>Rendezvous code instead of stop_machine for patching</h4>

<p>The hypervisor's time rendezvous code runs synchronously across all CPUs
every second. Using the <code>stop_machine</code> to patch can stall the time rendezvous
code and result in NMI. As such having the patching be done at the tail
of rendezvous code should avoid this problem.</p>

<p>However the entrance point for that code is <code>do_softirq -&gt;
timer_softirq_action -&gt; time_calibration</code> which ends up calling
<code>on_selected_cpus</code> on remote CPUs.</p>

<p>The remote CPUs receive CALL_FUNCTION_VECTOR IPI and execute the
desired function.</p>

<h4>Before entering the guest code.</h4>

<p>Before we call VMXResume we check whether any soft IRQs need to be executed.
This is a good spot because all Xen stacks are effectively empty at
that point.</p>

<p>To randezvous all the CPUs an barrier with an maximum timeout (which
could be adjusted), combined with forcing all other CPUs through the
hypervisor with IPIs, can be utilized to execute lockstep instructions
on all CPUs.</p>

<p>The approach is similar in concept to <code>stop_machine</code> and the time rendezvous
but is time-bound. However the local CPU stack is much shorter and
a lot more deterministic.</p>

<p>This is implemented in the Xen hypervisor.</p>

<h3>Compiling the hypervisor code</h3>

<p>Hotpatch generation often requires support for compiling the target
with <code>-ffunction-sections</code> / <code>-fdata-sections</code>.  Changes would have to
be done to the linker scripts to support this.</p>

<h3>Generation of Live Patch ELF payloads</h3>

<p>The design of that is not discussed in this design.</p>

<p>This is implemented in a seperate tool which lives in a seperate
GIT repo.</p>

<p>Currently it resides at git://xenbits.xen.org/livepatch-build-tools.git</p>

<h3>Exception tables and symbol tables growth</h3>

<p>We may need support for adapting or augmenting exception tables if
patching such code.  Hotpatches may need to bring their own small
exception tables (similar to how Linux modules support this).</p>

<p>If supporting hotpatches that introduce additional exception-locations
is not important, one could also change the exception table in-place
and reorder it afterwards.</p>

<p>As found almost every patch (XSA) to a non-trivial function requires
additional entries in the exception table and/or the bug frames.</p>

<p>This is implemented in the Xen hypervisor.</p>

<h3>.rodata sections</h3>

<p>The patching might require strings to be updated as well. As such we must be
also able to patch the strings as needed. This sounds simple - but the compiler
has a habit of coalescing strings that are the same - which means if we in-place
alter the strings - other users will be inadvertently affected as well.</p>

<p>This is also where pointers to functions live - and we may need to patch this
as well. And switch-style jump tables.</p>

<p>To guard against that we must be prepared to do patching similar to
trampoline patching or in-line depending on the flavour. If we can
do in-line patching we would need to:</p>

<ul>
<li>Alter <code>.rodata</code> to be writeable.</li>
<li>Inline patch.</li>
<li>Alter <code>.rodata</code> to be read-only.</li>
</ul>

<p>If are doing trampoline patching we would need to:</p>

<ul>
<li>Allocate a new memory location for the string.</li>
<li>All locations which use this string will have to be updated to use the
offset to the string.</li>
<li>Mark the region RO when we are done.</li>
</ul>

<p>The trampoline patching is implemented in the Xen hypervisor.</p>

<h3>.bss and .data sections.</h3>

<p>In place patching writable data is not suitable as it is unclear what should be done
depending on the current state of data. As such it should not be attempted.</p>

<p>However, functions which are being patched can bring in changes to strings
(.data or .rodata section changes), or even to .bss sections.</p>

<p>As such the ELF payload can introduce new .rodata, .bss, and .data sections.
Patching in the new function will end up also patching in the new .rodata
section and the new function will reference the new string in the new
.rodata section.</p>

<p>This is implemented in the Xen hypervisor.</p>

<h3>Security</h3>

<p>Only the privileged domain should be allowed to do this operation.</p>

<h3>Live patch interdependencies</h3>

<p>Live patch patches interdependencies are tricky.</p>

<p>There are the ways this can be addressed:
 * A single large patch that subsumes and replaces all previous ones.
   Over the life-time of patching the hypervisor this large patch
   grows to accumulate all the code changes.
 * Hotpatch stack - where an mechanism exists that loads the hotpatches
   in the same order they were built in. We would need an build-id
   of the hypevisor to make sure the hot-patches are build against the
   correct build.
 * Payload containing the old code to check against that. That allows
   the hotpatches to be loaded indepedently (if they don't overlap) - or
   if the old code also containst previously patched code - even if they
   overlap.</p>

<p>The disadvantage of the first large patch is that it can grow over
time and not provide an bisection mechanism to identify faulty patches.</p>

<p>The hot-patch stack puts stricts requirements on the order of the patches
being loaded and requires an hypervisor build-id to match against.</p>

<p>The old code allows much more flexibility and an additional guard,
but is more complex to implement.</p>

<p>The second option which requires an build-id of the hypervisor
is implemented in the Xen hypervisor.</p>

<p>Specifically each payload has two build-id ELF notes:
 * The build-id of the payload itself (generated via --build-id).
 * The build-id of the payload it depends on (extracted from the
   the previous payload or hypervisor during build time).</p>

<p>This means that the very first payload depends on the hypervisor
build-id.</p>

<h1>Not Yet Done</h1>

<p>This is for further development of live patching.</p>

<h2>TODO Goals</h2>

<p>The implementation must also have a mechanism for (in no particular order):</p>

<ul>
<li>Be able to lookup in the Xen hypervisor the symbol names of functions from the
ELF payload. (Either as <code>symbol</code> or <code>symbol</code>+<code>offset</code>).</li>
<li>Be able to patch .rodata, .bss, and .data sections.</li>
<li>Deal with NMI/MCE checks during patching instead of ignoring them.</li>
<li>Further safety checks (blacklist of which functions cannot be patched, check
the stack, make sure the payload is built with same compiler as hypervisor).
Specifically we want to make sure that live patching codepaths cannot be patched.</li>
<li>NOP out the code sequence if <code>new_size</code> is zero.</li>
<li>Deal with other relocation types:  R_X86_64_[8,16,32,32S], R_X86_64_PC[8,16,64]
in payload file.</li>
</ul>

<h3>Handle inlined __LINE__</h3>

<p>This problem is related to hotpatch construction
and potentially has influence on the design of the hotpatching
infrastructure in Xen.</p>

<p>For example:</p>

<p>We have file1.c with functions f1 and f2 (in that order).  f2 contains a
BUG() (or WARN()) macro and at that point embeds the source line number
into the generated code for f2.</p>

<p>Now we want to hotpatch f1 and the hotpatch source-code patch adds 2
lines to f1 and as a consequence shifts out f2 by two lines.  The newly
constructed file1.o will now contain differences in both binary
functions f1 (because we actually changed it with the applied patch) and
f2 (because the contained BUG macro embeds the new line number).</p>

<p>Without additional information, an algorithm comparing file1.o before
and after hotpatch application will determine both functions to be
changed and will have to include both into the binary hotpatch.</p>

<p>Options:</p>

<ol>
<li><p>Transform source code patches for hotpatches to be line-neutral for
each chunk.  This can be done in almost all cases with either
reformatting of the source code or by introducing artificial
preprocessor "#line n" directives to adjust for the introduced
differences.</p>

<p>This approach is low-tech and simple.  Potentially generated
backtraces and existing debug information refers to the original
build and does not reflect hotpatching state except for actually
hotpatched functions but should be mostly correct.</p></li>
<li><p>Ignoring the problem and living with artificially large hotpatches
that unnecessarily patch many functions.</p>

<p>This approach might lead to some very large hotpatches depending on
content of specific source file.  It may also trigger pulling in
functions into the hotpatch that cannot reasonable be hotpatched due
to limitations of a hotpatching framework (init-sections, parts of
the hotpatching framework itself, ...) and may thereby prevent us
from patching a specific problem.</p>

<p>The decision between 1. and 2. can be made on a patch--by-patch
basis.</p></li>
<li><p>Introducing an indirection table for storing line numbers and
treating that specially for binary diffing. Linux may follow
this approach.</p>

<p>We might either use this indirection table for runtime use and patch
that with each hotpatch (similarly to exception tables) or we might
purely use it when building hotpatches to ignore functions that only
differ at exactly the location where a line-number is embedded.</p></li>
</ol>

<p>For BUG(), WARN(), etc., the line number is embedded into the bug frame, not
the function itself.</p>

<p>Similar considerations are true to a lesser extent for __FILE__, but it
could be argued that file renaming should be done outside of hotpatches.</p>

<h2>Signature checking requirements.</h2>

<p>The signature checking requires that the layout of the data in memory
<strong>MUST</strong> be same for signature to be verified. This means that the payload
data layout in ELF format <strong>MUST</strong> match what the hypervisor would be
expecting such that it can properly do signature verification.</p>

<p>The signature is based on the all of the payloads continuously laid out
in memory. The signature is to be appended at the end of the ELF payload
prefixed with the string '<code>~Module signature appended~\n</code>', followed by
an signature header then followed by the signature, key identifier, and signers
name.</p>

<p>Specifically the signature header would be:</p>

<pre><code>#define PKEY_ALGO_DSA       0
#define PKEY_ALGO_RSA       1

#define PKEY_ID_PGP         0 /* OpenPGP generated key ID */
#define PKEY_ID_X509        1 /* X.509 arbitrary subjectKeyIdentifier */

#define HASH_ALGO_MD4          0
#define HASH_ALGO_MD5          1
#define HASH_ALGO_SHA1         2
#define HASH_ALGO_RIPE_MD_160  3
#define HASH_ALGO_SHA256       4
#define HASH_ALGO_SHA384       5
#define HASH_ALGO_SHA512       6
#define HASH_ALGO_SHA224       7
#define HASH_ALGO_RIPE_MD_128  8
#define HASH_ALGO_RIPE_MD_256  9
#define HASH_ALGO_RIPE_MD_320 10
#define HASH_ALGO_WP_256      11
#define HASH_ALGO_WP_384      12
#define HASH_ALGO_WP_512      13
#define HASH_ALGO_TGR_128     14
#define HASH_ALGO_TGR_160     15
#define HASH_ALGO_TGR_192     16

struct elf_payload_signature {
    u8  algo;       /* Public-key crypto algorithm PKEY_ALGO_*. */
    u8  hash;       /* Digest algorithm: HASH_ALGO_*. */
    u8  id_type;    /* Key identifier type PKEY_ID*. */
    u8  signer_len; /* Length of signer's name */
    u8  key_id_len; /* Length of key identifier */
    u8  __pad[3];
    __be32  sig_len;    /* Length of signature data */
};
</code></pre>

<p>(Note that this has been borrowed from Linux module signature code.).</p>

<h3>.bss and .data sections.</h3>

<p>In place patching writable data is not suitable as it is unclear what should be done
depending on the current state of data. As such it should not be attempted.</p>

<p>That said we should provide hook functions so that the existing data
can be changed during payload application.</p>

<p>To guarantee safety we disallow re-applying an payload after it has been
reverted. This is because we cannot guarantee that the state of .bss
and .data to be exactly as it was during loading. Hence the administrator
MUST unload the payload and upload it again to apply it.</p>

<p>There is an exception to this: if the payload only has .livepatch.funcs;
and the .data or .bss sections are of zero length.</p>

<h3>Inline patching</h3>

<p>The hypervisor should verify that the in-place patching would fit within
the code or data.</p>

<h3>Trampoline (e9 opcode), x86</h3>

<p>The e9 opcode used for jmpq uses a 32-bit signed displacement. That means
we are limited to up to 2GB of virtual address to place the new code
from the old code. That should not be a problem since Xen hypervisor has
a very small footprint.</p>

<p>However if we need - we can always add two trampolines. One at the 2GB
limit that calls the next trampoline.</p>

<p>Please note there is a small limitation for trampolines in
function entries: The target function (+ trailing padding) must be able
to accomodate the trampoline. On x86 with +-2 GB relative jumps,
this means 5 bytes are required which means that <code>old_size</code> <strong>MUST</strong> be
at least five bytes if patching in trampoline.</p>

<p>Depending on compiler settings, there are several functions in Xen that
are smaller (without inter-function padding).</p>

<pre><code>readelf -sW xen-syms | grep " FUNC " | \
    awk '{ if ($3 &lt; 5) print $3, $4, $5, $8 }'

...
3 FUNC LOCAL wbinvd_ipi
3 FUNC LOCAL shadow_l1_index
...
</code></pre>

<p>A compile-time check for, e.g., a minimum alignment of functions or a
runtime check that verifies symbol size (+ padding to next symbols) for
that in the hypervisor is advised.</p>

<p>The tool for generating payloads currently does perform a compile-time
check to ensure that the function to be replaced is large enough.</p>

<h4>Trampoline, ARM</h4>

<p>The unconditional branch instruction (for the encoding see the
DDI 0406C.c and DDI 0487A.j Architecture Reference Manual's).
with proper offset is used for an unconditional branch to the new code.
This means that that <code>old_size</code> <strong>MUST</strong> be at least four bytes if patching
in trampoline.</p>

<p>The instruction offset is limited on ARM32 to +/- 32MB to displacement
and on ARM64 to +/- 128MB displacement.</p>

<p>The new code is placed in the 8M - 10M virtual address space while the
Xen code is in 2M - 4M. That gives us enough space.</p>

<p>The hypervisor also checks the displacement during loading of the payload.</p>
